(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{578:function(v,_,t){"use strict";t.r(_);var T=t(10),a=Object(T.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"http不同版本的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http不同版本的区别"}},[v._v("#")]),v._v(" http不同版本的区别")]),v._v(" "),t("h2",{attrs:{id:"http0-9"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http0-9"}},[v._v("#")]),v._v(" http0.9")]),v._v(" "),t("ul",[t("li",[v._v("第一个是只有一个请求行，并没有HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。")]),v._v(" "),t("li",[v._v("第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。")]),v._v(" "),t("li",[v._v("第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的")])]),v._v(" "),t("h2",{attrs:{id:"http1-0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[v._v("#")]),v._v(" http1.0")]),v._v(" "),t("ul",[t("li",[v._v("需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头")]),v._v(" "),t("li",[v._v("有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。")]),v._v(" "),t("li",[v._v("为了减轻服务器的压力，在 HTTP/1.0 中提供了Cache 机制，用来缓存已经下载过的数据。")])]),v._v(" "),t("h2",{attrs:{id:"http1-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[v._v("#")]),v._v(" http1.1")]),v._v(" "),t("p",[t("strong",[v._v("优点")])]),v._v(" "),t("ol",[t("li",[v._v("改进持久连接\n"),t("ul",[t("li",[v._v("HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。")])])]),v._v(" "),t("li",[v._v("浏览器为每个域名最多同时维护 6 个 TCP 持久连接")]),v._v(" "),t("li",[v._v("不成熟的 HTTP 管线化\n"),t("ul",[t("li",[v._v("持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。")]),v._v(" "),t("li",[v._v("HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。")]),v._v(" "),t("li",[v._v("FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。")])])])]),v._v(" "),t("p",[t("strong",[v._v("缺点")])]),v._v(" "),t("ol",[t("li",[v._v("tcp的慢启动\n"),t("ul",[t("li",[v._v("一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。")]),v._v(" "),t("li",[v._v("你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。")]),v._v(" "),t("li",[v._v("慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。")]),v._v(" "),t("li",[v._v("而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。")])])]),v._v(" "),t("li",[v._v("同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。\n"),t("ul",[t("li",[v._v("你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。")]),v._v(" "),t("li",[v._v("这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。")])])]),v._v(" "),t("li",[v._v("HTTP/1.1 队头阻塞的问题\n"),t("ul",[t("li",[v._v("我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。")]),v._v(" "),t("li",[v._v("这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。")]),v._v(" "),t("li",[v._v("在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。")]),v._v(" "),t("li",[v._v("但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。")])])])]),v._v(" "),t("h2",{attrs:{id:"http2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[v._v("#")]),v._v(" http2")]),v._v(" "),t("h3",{attrs:{id:"http2的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2的优点"}},[v._v("#")]),v._v(" HTTP2的优点")]),v._v(" "),t("h4",{attrs:{id:"_1-多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-多路复用"}},[v._v("#")]),v._v(" 1.多路复用")]),v._v(" "),t("blockquote",[t("p",[v._v("HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。")])]),v._v(" "),t("h2",{attrs:{id:"多路复用的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多路复用的实现"}},[v._v("#")]),v._v(" 多路复用的实现")]),v._v(" "),t("p",[v._v("现在我们知道为了解决 HTTP/1.1 存在的问题，HTTP/2 采用了多路复用机制，那 HTTP/2 是怎么实现多路复用的呢？你可以先看下面这张图：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251647048.png",alt:"image-20220125164715937"}})]),v._v(" "),t("p",[v._v("HTTP/2 协议栈")]),v._v(" "),t("p",[v._v("从图中可以看出，HTTP/2 添加了一个"),t("strong",[v._v("二进制分帧层")]),v._v("，那我们就结合图来分析下 HTTP/2 的请求和接收过程。")]),v._v(" "),t("ul",[t("li",[v._v("首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。")]),v._v(" "),t("li",[v._v("这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。")]),v._v(" "),t("li",[v._v("服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。")]),v._v(" "),t("li",[v._v("然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。")]),v._v(" "),t("li",[v._v("同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。")]),v._v(" "),t("li",[v._v("浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。")])]),v._v(" "),t("p",[v._v("从上面的流程可以看出，"),t("strong",[v._v("通过引入二进制分帧层，就实现了 HTTP 的多路复用技术")]),v._v("。")]),v._v(" "),t("h4",{attrs:{id:"_2-可以设置请求的优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-可以设置请求的优先级"}},[v._v("#")]),v._v(" 2.可以设置请求的优先级")]),v._v(" "),t("p",[v._v("我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。")]),v._v(" "),t("p",[v._v("为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。")]),v._v(" "),t("h4",{attrs:{id:"_2-服务器推送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务器推送"}},[v._v("#")]),v._v(" 2. 服务器推送")]),v._v(" "),t("p",[v._v("除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。")]),v._v(" "),t("h4",{attrs:{id:"_3-头部压缩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-头部压缩"}},[v._v("#")]),v._v(" 3. 头部压缩")]),v._v(" "),t("p",[v._v("无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。")]),v._v(" "),t("h3",{attrs:{id:"http2的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2的缺点"}},[v._v("#")]),v._v(" http2的缺点")]),v._v(" "),t("h4",{attrs:{id:"_1-tcp-的队头阻塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp-的队头阻塞"}},[v._v("#")]),v._v(" 1.TCP 的队头阻塞")]),v._v(" "),t("p",[v._v("虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。")]),v._v(" "),t("p",[v._v("接下来我们就来分析下 HTTP/1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251747509.png",alt:"image-20220125174745466"}})]),v._v(" "),t("p",[v._v("通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。")]),v._v(" "),t("p",[v._v("不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251750680.png",alt:"image-20220125175038627"}})]),v._v(" "),t("p",[v._v("我们就把"),t("strong",[v._v("在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞")]),v._v("。")]),v._v(" "),t("p",[v._v("那队头阻塞是怎么影响 HTTP/2 传输的呢？首先我们来看正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，你可以参考下图：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251751458.png",alt:"image-20220125175125410"}})]),v._v(" "),t("p",[v._v("通过该图，我们知道在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。")]),v._v(" "),t("p",[v._v("所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。")]),v._v(" "),t("h3",{attrs:{id:"tcp-建立连接的延时"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-建立连接的延时"}},[v._v("#")]),v._v(" TCP 建立连接的延时")]),v._v(" "),t("p",[v._v("除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。")]),v._v(" "),t("p",[v._v("为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来回顾下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251758843.png",alt:"image-20220125175820802"}})]),v._v(" "),t("p",[v._v("那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。")]),v._v(" "),t("p",[v._v("我们知道 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。")]),v._v(" "),t("ol",[t("li",[v._v("在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。")]),v._v(" "),t("li",[v._v("进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍。")])]),v._v(" "),t("p",[v._v("总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。")]),v._v(" "),t("h4",{attrs:{id:"_4-tcp-协议僵化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp-协议僵化"}},[v._v("#")]),v._v(" 4.TCP 协议僵化")]),v._v(" "),t("p",[v._v("现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？")]),v._v(" "),t("p",[v._v("答案是："),t("strong",[v._v("非常困难")]),v._v("。之所以这样，主要有两个原因。")]),v._v(" "),t("p",[v._v("第一个是"),t("strong",[v._v("中间设备的僵化")]),v._v("。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。")]),v._v(" "),t("p",[v._v("这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。")]),v._v(" "),t("p",[v._v("所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。")]),v._v(" "),t("p",[v._v("除了中间设备僵化外，"),t("strong",[v._v("操作系统也是导致 TCP 协议僵化的另外一个原因")]),v._v("。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。")]),v._v(" "),t("h2",{attrs:{id:"quic-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quic-协议"}},[v._v("#")]),v._v(" QUIC 协议")]),v._v(" "),t("p",[v._v("HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。")]),v._v(" "),t("p",[v._v("因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为"),t("strong",[v._v("QUIC 协议")]),v._v("。关于 HTTP/2 和 HTTP/3 协议栈的比较，你可以参考下图：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.viini.cn/img/202201251801753.png",alt:"image-20220125180102707"}})]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("实现了快速握手功能")]),v._v("。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。")])]),v._v(" "),t("h2",{attrs:{id:"http-3-的挑战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-3-的挑战"}},[v._v("#")]),v._v(" HTTP/3 的挑战")]),v._v(" "),t("p",[v._v("通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。")]),v._v(" "),t("p",[v._v("第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。")]),v._v(" "),t("p",[v._v("第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。")]),v._v(" "),t("p",[v._v("第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。")])])}),[],!1,null,null,null);_.default=a.exports}}]);