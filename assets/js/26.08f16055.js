(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{586:function(v,t,_){"use strict";_.r(t);var a=_(10),e=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vuejs模板编译分为三个部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vuejs模板编译分为三个部分"}},[v._v("#")]),v._v(" vuejs模板编译分为三个部分：")]),v._v(" "),_("ol",[_("li",[v._v("将html模板编译为ast对象")]),v._v(" "),_("li",[v._v("优化，遍历 AST，为每个节点做静态标记，标记其是否为静态节点，然后进一步标记出静态根节点，这样在后续更新的过程中就可以跳过这些静态节点了；标记静态根用于生成渲染函数阶段，生成静态根节点的渲染函数")]),v._v(" "),_("li",[v._v("从ast生成render函数和staticRenderFns数组(存放了所有静态节点的渲染函数)")])]),v._v(" "),_("h2",{attrs:{id:"_1-vue模板编译的解析流程-是怎么将-html-字符串模版变成-ast-对象的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue模板编译的解析流程-是怎么将-html-字符串模版变成-ast-对象的"}},[v._v("#")]),v._v(" 1.vue模板编译的解析流程，是怎么将 html 字符串模版变成 AST 对象的？")]),v._v(" "),_("ul",[_("li",[v._v('遍历html模板字符串，通过正则表达式来匹配"<"')]),v._v(" "),_("li",[v._v("跳过一些不需要处理的标签，比如：注释标签，条件匹配标签，Doctype\n"),_("blockquote",[_("p",[v._v("整个模板解析的核心就是处理开始标签和结束标签以及文件标签")])])]),v._v(" "),_("li",[v._v("解析开始标签\n"),_("ul",[_("li",[v._v("得到一个对象，包括 标签名（tagName）、所有的属性（attrs）、标签在 html 模版字符串中的索引位置")]),v._v(" "),_("li",[v._v("再次处理上次得到的attr属性，将其变成[{name: attrName, value: attrVal, start: xx, end: xx}]")]),v._v(" "),_("li",[v._v("然后标签名，属性对象，和当前元素的父亲元素生成ast对象；ast其实就是一个普通的js对象，然后通过key，value的形式记录了元素的一些信息")]),v._v(" "),_("li",[v._v("然后进一步处理ast上面的一些指令，例如：v-pre，v-for，v-if，v-once，并将处理结果放到ast对象上")]),v._v(" "),_("li",[v._v("如果是一元标签就自动执行闭合标签的逻辑，如果不是一元标签就将处理完的ast对象存放到stack数组中")]),v._v(" "),_("li",[v._v("处理完之后会截断html字符串，将已经处理掉的字符串戒掉")])])]),v._v(" "),_("li",[v._v("解析闭合标签\n"),_("ul",[_("li",[v._v("如果匹配到结束标签，就从stack数组中拿出最后一个元素，它和当前匹配到的结束标签是一对的。如果没找到的话就报错。")]),v._v(" "),_("li",[v._v("然后再次处理开始标签上的属性，这些属性和前面处理的不一样，比如key，ref，插槽，class，style，动态组件等，并将处理完的结果放到ast对象上")]),v._v(" "),_("li",[v._v("然后将当前元素和父元素产生联系，给当前元素的 ast 对象设置 parent 属性，然后将自己放到父元素的 ast 对象的 children 数组中")])])]),v._v(" "),_("li",[v._v("解析文本标签\n"),_("ul",[_("li",[v._v("静态标签分为两种：type为 2 表示是表达式，type为 3 表示是纯文本。")]),v._v(" "),_("li",[v._v("如果标签是"),_("code",[v._v("<div>"+v._s(v.age)+"</div>")]),v._v("中，那"),_("code",[v._v(v._s(v.age))]),v._v("是表达式")]),v._v(" "),_("li",[v._v("如果标签是这样的"),_("code",[v._v("<div>123</div>")]),v._v("中，那"),_("code",[v._v("123")]),v._v("是纯文本标签")]),v._v(" "),_("li",[v._v("然后添加到父节点中")])])]),v._v(" "),_("li",[v._v("最后遍历完整个 html 模版字符串以后，返回 ast 对象")])]),v._v(" "),_("h2",{attrs:{id:"_2-优化ast"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-优化ast"}},[v._v("#")]),v._v(" 2.优化ast")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 patch 的过程跳过对他们的比对。")])]),v._v(" "),_("p",[v._v("静态标记的过程分为两个步骤，标记静态节点和静态根节点")]),v._v(" "),_("h3",{attrs:{id:"标记静态节点我们首先得知道什么是静态节点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记静态节点我们首先得知道什么是静态节点"}},[v._v("#")]),v._v(" 标记静态节点我们首先得知道什么是静态节点")]),v._v(" "),_("ul",[_("li",[v._v("如果是表达式，就是非静态；")]),v._v(" "),_("li",[v._v("如果是纯文本，就是静态；")]),v._v(" "),_("li",[v._v("对于一个普通元素，如果有 pre 属性，那么它使用了 v-pre 指令，是静态，否则要同时满足以下条件：没有使用 v-if、v-for，没有使用其它指令（不包括 v-once），非内置组件，是平台保留的标签，非带有 v-for 的 template 标签的直接子节点，节点的所有属性的 key 都满足静态 key；这些都满足则这个 AST 节点是一个静态节点。")])]),v._v(" "),_("h3",{attrs:{id:"标记静态节点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记静态节点"}},[v._v("#")]),v._v(" 标记静态节点")]),v._v(" "),_("ul",[_("li",[v._v("通过递归的方式，标记所有的元素节点")]),v._v(" "),_("li",[v._v("如果节点本身是静态节点，但是存在非静态节点的子节点，那么修改节点为非静态节点")])]),v._v(" "),_("h3",{attrs:{id:"标记静态根节点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记静态根节点"}},[v._v("#")]),v._v(" 标记静态根节点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("如果节点本身是静态节点 && 而且有子节点 && 而且子节点不只是一个文本节点，则标记为静态根节点，否则标记为非静态根节点")])]),v._v(" "),_("li",[_("p",[v._v("如果节点本身不是静态根节点，则递归的遍历所有子节点，在子节点中标记静态根")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);